# Copyright (c) 2021 ipyradiant contributors.
# Distributed under the terms of the Modified BSD License.

import ipywidgets as W
import traitlets as T
from IPython.display import JSON, display
from rdflib.graph import Graph as RDFGraph
from rdflib.term import URIRef

from ipyradiant.basic_tools.custom_uri_ref import CustomURIRef
from ipyradiant.query.framer import SPARQLQueryFramer
from ipyradiant.visualization.cytoscape import style
from ipyradiant.visualization.cytoscape.viewer import CytoscapeViewer

# Ranked by pairwise distance (generated by https://mokole.com/palette.html)
COLOR_LIST = [
    (47, 79, 79),
    (85, 107, 47),
    (139, 69, 19),
    (34, 139, 34),
    (72, 61, 139),
    (184, 134, 11),
    (70, 130, 180),
    (0, 0, 128),
    (127, 0, 127),
    (143, 188, 143),
    (176, 48, 96),
    (255, 69, 0),
    (255, 255, 0),
    (0, 255, 0),
    (138, 43, 226),
    (0, 255, 127),
    (220, 20, 60),
    (0, 255, 255),
    (0, 0, 255),
    (173, 255, 47),
    (218, 112, 214),
    (255, 127, 80),
    (255, 0, 255),
    (30, 144, 255),
    (144, 238, 144),
    (173, 216, 230),
    (255, 20, 147),
    (123, 104, 238),
    (255, 222, 173),
    (255, 192, 203),
]

# convert COLOR_LIST to ipycytoscape css format
COLOR_LIST_CSS = [f"rgb({r},{g},{b})" for r, g, b in COLOR_LIST]


def get_desc(uri, namespaces, count=None):
    """Get a shorthand way to describe a URI and its counts."""

    shorthand = str(CustomURIRef(uri, namespaces=namespaces))
    if count:
        return f"{shorthand}  [{count}]"


class TypeCount(SPARQLQueryFramer):
    """Get types and their count.

    TODO support users to extend based on unique predicates for type (e.g., ex:type)
    """

    sparql = """
    SELECT DISTINCT ?type_ (COUNT(?node) AS ?count)
    WHERE {
        ?node a ?type_ .
    }
    GROUP BY ?type_
    """


class PredicateCount(SPARQLQueryFramer):
    """Get predicates and their count.

    TODO how is this related to the RDF2NX edge query?
    """

    sparql = """
    SELECT DISTINCT ?predicate (COUNT(?subject) AS ?count)
    WHERE {
        ?subject ?predicate ?object .

        FILTER (?predicate != rdf:type)  # probably do not want this
        FILTER ( isIRI ( ?object ) )     # only want predicates in the LPG
    }
    GROUP BY ?predicate
    """


class InteractiveViewer(W.GridspecLayout):
    """Graph visualization for viewing RDF graphs as LPGs. The InteractiveViewer
      provides a method for reducing the amount of displayed information through a
      multi-select widget for `rdf:type` and all predicates in the graph. Users
      can choose which types/edges they want to see, and the visualization will
      update the corresponding nodes/edges.

    TODO document how users can extend the type_count_query

    :param graph: the rdflib.graph.Graph to display
    :param type_count_query: the query class used to collect valid rdf:types
    :param predicate_count_query: the query class used to collect valid predicates
    """

    graph = T.Instance(RDFGraph, kw={})
    type_selector = T.Instance(W.SelectMultiple)
    predicate_selector = T.Instance(W.SelectMultiple)
    viewer = T.Instance(CytoscapeViewer)
    json_output = T.Instance(W.Output)

    type_count_query = TypeCount
    predicate_count_query = PredicateCount
    uri_to_string_type = {}  # map
    iri_to_node = {}  # map

    def __init__(self, n_rows=4, n_columns=5, **kwargs):
        super().__init__(n_rows=n_rows, n_columns=n_columns, **kwargs)

    def load_json(self, node):
        data = node["data"]
        data.pop("_label", None)
        data.pop("_attrs", None)
        with self.json_output:
            self.json_output.clear_output()
            display(JSON(data))

    def update_classes(self, change):
        """Updates the CSS classes for nodes/edges.

        TODO optimize so that we don't have to iterate through every node/edge?
        """

        # use selectors to determine visible nodes/edges
        visible_node_types = set(self.type_selector.value)
        visible_edge_types = set(self.predicate_selector.value)

        # set visibility for all nodes (only needed for node changes)
        if change.owner.type_ == "node_type":
            for node in self.viewer.cytoscape_widget.graph.nodes:
                raw_types = node.data["rdf:type"]
                types = raw_types if type(raw_types) is tuple else (raw_types,)
                if not any([_type in visible_node_types for _type in types]):
                    node.classes = "invisible"
                else:
                    node.classes = ""

        # set visibility for all edges (needed for node and edge changes)
        for edge in self.viewer.cytoscape_widget.graph.edges:
            source_node = self.iri_to_node[edge.data["source"]]
            target_node = self.iri_to_node[edge.data["target"]]

            if edge.data["predicate"] not in visible_edge_types:
                edge.classes = "invisible"
            elif (
                "invisible" in source_node.classes or "invisible" in target_node.classes
            ):
                edge.classes = "invisible"
            else:
                edge.classes = "directed"

        # update front-end (set_style must receive a copy)
        self.viewer.cytoscape_widget.set_style(
            list(self.viewer.cytoscape_widget.get_style())
        )

    def _ipython_display_(self, **kwargs):
        super()._ipython_display_(**kwargs)
        self._set_layout()

    def _set_layout(self):
        layout = self.layout
        layout.height = "80vh"
        layout.width = "auto"

        self[0:3, :1] = W.VBox(
            [
                W.VBox(
                    [
                        W.Label("Types:"),
                        self.type_selector,
                        W.Label("Edges:"),
                        self.predicate_selector,
                    ]
                ),
            ]
        )
        self[0:3, 1:] = self.viewer
        self[3, 1:] = self.json_output

        for widget in (
            self.type_selector,
            self.predicate_selector,
            self.viewer,
        ):
            widget.layout.height = "auto"
            widget.layout.width = "auto"
            widget.layout.min_height = None
            widget.layout.max_height = None
            widget.layout.max_width = None
            widget.layout.min_width = None

        self.layout = layout

    @T.default("json_output")
    def _make_default_json_output(self):
        widget = W.Output()
        # Prevent resizing the JSON output from changing other widgets
        widget.layout.overflow_y = "auto"
        widget.layout.width = "auto"
        return widget

    @T.default("viewer")
    def _make_default_viewer(self):
        widget = CytoscapeViewer()
        T.link((self, "graph"), (widget, "graph"))
        widget.cytoscape_widget.on("node", "click", self.load_json)
        return widget

    @T.default("type_selector")
    def _make_default_type_selector(self):
        widget = W.SelectMultiple()
        # set a type for the observer to read
        widget.type_ = "node_type"
        widget.observe(self.update_classes, "value")
        return widget

    @T.default("predicate_selector")
    def _make_default_predicate_selector(self):
        widget = W.SelectMultiple()
        # set a type for the observer to read
        widget.type_ = "predicate"
        widget.observe(self.update_classes, "value")
        return widget

    @T.validate("children")
    def validate_children(self, proposal):
        """
        Validate method for default children.
        This is necessary because @trt.default does not work on children.
        """
        children = proposal.value
        if not children:
            children = (
                W.HBox(
                    [
                        W.VBox(
                            [
                                W.Label("Types:"),
                                self.type_selector,
                                W.Label("Edges:"),
                                self.predicate_selector,
                            ]
                        ),
                        self.viewer,
                    ]
                ),
                self.json_output,
            )

        return children

    @T.observe("graph")
    def update_graph(self, change):
        """When the graph is changed, updates the corresponding widget elements.

        TODO break up method into smaller parts?
        """
        graph = change.new
        self.viewer.graph = graph  # force update now

        # node_iri to node (for mapping to edges)
        # TODO is there a way to enhance/use the adjacency matrix?
        self.iri_to_node = {
            str(node.data["iri"]): node
            for node in self.viewer.cytoscape_widget.graph.nodes
        }

        # run type and predicate query
        type_count = self.type_count_query.run_query(
            self.graph,
        ).sort_values(by=["count"], ascending=False)

        predicate_count = self.predicate_count_query.run_query(
            self.graph,
        ).sort_values(by=["count"], ascending=False)

        # map type URIs to their css class name for ipycytoscape
        self.uri_to_string_type = {
            uri: str(CustomURIRef(uri, namespaces=graph.namespace_manager)).replace(
                ":", "-"
            )
            for uri in type_count.type_
        }
        self.uri_to_string_type["multi-type"] = "multi-type"

        # build options for the type MultiSelect
        select_options = []
        for uri, count in type_count.values:
            description = get_desc(uri, graph.namespace_manager, count)
            select_options.append((description, uri))

        # set options, value, and row counts
        self.type_selector.options = select_options
        self.type_selector.value = tuple(uri for _, uri in select_options)
        self.type_selector.rows = len(select_options)

        # build options for the predicate MultiSelect
        select_options = []
        for uri, count in predicate_count.values:
            description = get_desc(uri, graph.namespace_manager, count)
            select_options.append((description, uri))

        # set options, value, and row counts
        self.predicate_selector.options = select_options
        self.predicate_selector.value = tuple(uri for _, uri in select_options)
        self.predicate_selector.rows = len(select_options)

        # assign colors to css classes
        assert len(self.uri_to_string_type.keys()) <= len(
            COLOR_LIST
        ), f"Cannot render more than {len(COLOR_LIST)} visually disctinct colors."
        color_type_map = list(
            zip([*self.uri_to_string_type.values(), "multi-type"], COLOR_LIST_CSS)
        )

        # assign CSS classes to nodes based on their rdf:type
        # TODO add types instead of replacing once we figure out how to make partial matches of css classes in ipycytoscape
        for node in self.viewer.cytoscape_widget.graph.nodes:
            node_types = node.data.get("rdf:type", [])
            if type(node_types) == URIRef:
                node_types = (node_types,)

            if len(node_types) == 1:
                # assign specific class to node
                assert node_types[0] in self.uri_to_string_type
                css_class = self.uri_to_string_type[node_types[0]]
                node.data["type_"] = css_class
            else:
                node.data["type_"] = "multi-type"

        # use css data attribute style to color based on type
        color_classes = []
        for class_name, rgb_code in color_type_map:
            color_classes.append(
                {
                    "selector": f"node[type_ = '{class_name}']",
                    "style": {
                        "background-color": f"{rgb_code}",
                    },
                }
            )

        # change the cytoscape widget style
        old_style = list(self.viewer.cytoscape_widget.get_style())  # must be a copy!
        old_style.extend([*color_classes, style.INVISIBLE_NODE, style.INVISIBLE_EDGE])
        self.viewer.cytoscape_widget.set_style(old_style)
